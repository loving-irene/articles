### 类结构
    class class_name{
        属性区域
        
        方法区域
    }
类定义包含两个部分，一个部分是属性，一个部分是方法。
属性区域里用来放置所有的属性包括类常量、静态属性、普通属性，方法区域用来放置所有的方法，包括魔术方法和自定义方法，自定义方法也区分普通和静态。

***

#### 属性区域
    class class_name{
        #属性区域
        类常量
        普通属性
        静态属性
    }
进一步细分，属性区域可以分为类`常量+自定义属性`,常量依附于类，自定义属性依附于对象，依附于类使用时要使用类调用，依附于对象，使用时要使用对象调用。

类调用和对象调用在形式上面有区别  
  
**类调用**  
class_name::属性名,class_name::常量名  

**对象调用**  
$obj->属性名

***

#### 方法区域
    class class_name{
        #方法区域
        魔术方法
        自定义方法
    }
进一步细分，方法区域可以分为`魔术方法+自定义方法`，其中魔术方法是在特定条件下触发，不需要单独的调用，自定义方法是需要调用的。  

***

#### 访问级别
自定义的属性和方法都必须要使用访问修饰符来进行修饰，起到的效果类似于文件访问的权限限制，决定属性或方法是否暴露在当前环境中，包括了3种级别，public/protected/private  

public的限制最为宽松，可以理解为没有限制；protected只能在本类以及子类中访问（家族用）；private最为严格，只能在本类中访问（自己用）。

***

#### 魔术方法
魔术方法具有如下特点：  
 1.命名形式，以__开头，为了避免混淆，自定义方法的命名不使用__作为前缀。  
 2.条件触发，而不需要主动调用。
 
方法名|描述
-|-
__sleep()|serialize()会检查类中是否有__sleep()函数，如果有，会先执行它
__wakeup()|unserialize()会检查类中是否有__wakeup()函数，如果有，会先执行它
__toString()|当一个类被当成一个字符串对待时，触发该函数，如echo $obj
__invoke()|当尝试以调用函数的方式调用一个对象时，__invoke会被自动触发
__set_state()|当调用var_export()导出类时，此静态方法会被调用
__debuginfo()|当调用var_dump()输出类时，如果该方法定义了，则调用该方法，否则输出该类的所有级别的属性


魔术方法下特殊的分类，解析和析构


方法名|描述
-|-
__construct()|创建一个对象时，主动调用，一般用来进行一些初始化操作
__destruct()|当对象的所有引用被删除或者被销毁时，调用，一般用来进行收尾功能


魔术方法下的另一类，重载。当调用当前环境下未定义或者不可见的属性或方法时，重载方法会被调用。属性重载只能在对象中进行，并且在静态方法中，这些重载方法都不会被调用，所以，这些方法必须被声明为非静态。

方法名|描述
-|-
__set()|给不可访问属性赋值时被调用,不可访问包括没有定义以及不可见
__get()|读取不可访问属性时会被调用,不可访问包括没有定义以及不可见
__isset()|当对不可访问属性调用isset()或empty()时，__isset()会被调用
__unset()|当对不可访问属性调用unset()时，__isset()会被调用
